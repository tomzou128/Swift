# Function and Closure
## Difference between function and closure
Definition differences:
```
//This is a function
func <name>(<parameters>) -> <return type> {
    <function body>
}

//This is a closure
{ (<parameters>) -> <return type> in
    <statements>
}
```
Closure doesn't have a name, and it is ususally used as a parameter in function, or for communcation between objects.
<br>

### From function to closure
Closure are not limited to 1 line. <br>
Function to begin with:
```swift
func add(n1: Int, n2: Int) -> Int {
    return n1 + n2
}
```
Closures start from long to short, any one of them works:
```swift
cal(n1: Int, n2: Int, op: { (n1: Int, n2: Int) -> Int in return n1 + n2 } )
```
Remove data type:
```swift
cal(n1: Int, n2: Int, op: { (n1, n2) in return n1 + n2 } )
```
Remove return:
```swift
cal(n1: Int, n2: Int, op: { (n1, n2) in n1 + n2 } )
```
$0 means 1st parameter, $1 means 2nd parameter:
```swift
cal(n1: Int, n2: Int, op: { $0 + $1 } )
```
Extreme:
```swift
cal(n1: Int, n2: Int) {$0 + $1}
```
<br>

## Closure
### Two ways to combine a variable with conditons
1. Use closure, later call it like a function. (seems useless??)
```swift
var hardness = { () -> Int in
    if sender.currentTitle! == "Soft" {
        return self.softTime
    } else if sender.currentTitle! == "Medium"{
        return self.mediumTime
    } else {
        return self.hardTime
    }
}
        
print(hardness())
```
2. Use get, later call it like a normal variable.
```swift
var hardness: Int {
    get {
        switch sender.currentTitle! {
        case "Soft":
            return self.softTime
        case "Medium":
            return self.mediumTime
        case "Hard":
            return self.hardTime
        default:
            return -1
        }
    }
}
print(hardness)
```
