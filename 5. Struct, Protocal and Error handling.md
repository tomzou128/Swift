#  Struct, Protocol and Error handling
Include: Euum, Struct, Protocal, Extension and Error handling.
</br>

## Enumerate with Struct
Enumerate can list all the user-defined cases we want.
```swift
enum Fruit_type {
    case apple
    case pear
    case peach
    case banana
}
```
We can even add functions to enumearte in order to show more information.

```swift
enum Fruit_type {
    case apple
    case pear
    case peach
    case banana
    
    func unit_price() -> Double {
        switch self {
        case .apple: return 20
        case .pear: return 21
        case .peach: return 24
        case .banana: return 30
        }
    }
}
```
We can then use it in a struct. Note that system will automatically provide initializer for a struct. But since we don't want to modify the ```unit_price``` from outside, we must write our own initialier.
```swift
struct fruit{
    var fruit_type: Fruit_type
    var unit_price: 
    var weight: Double
    
    init(fruit_type: Fruit_type, weight: Double) {
        self.fruit_type = fruit_type
        self.weight = weight
        unit_price = fruit_type.unit_price()
    }
}

var apple1 = fruit(fruit_type: .apple, weight: 100)
```
</br>

## Protocol
Protocol is used to define rules that a class/struct/enum **must** follow. </br>
If protocol requires variable to be ```get set```, then this variable can't be constant or read-only type. If protocol requires varible to be ```get```, then this variable can be both readable and writable. When a function changes the value in its instance, it must have a ```mutating``` prefix in front in protocol.
```swift
protocol Tax {
    var national: Double { get }
    var state: Double { get set }
    var individual: Double { get set }
    mutating func changeStateTax (newTax: Double)
}
```
In here ```Ohio``` follows ```Tax``` protocol, so it must have those 3 variables and 1 function in it. And it doesn't need to write ```mutating``` in front of the function since it is a class.
```swift
class Ohio: Tax {
    func changeStateTax(newTax: Double) {
        state = newTax
    }
    
    var national: Double = 0.25
    var state: Double = 0.03
    var individual: Double = 0.1
}
```
</br>

## Extension
Extension can be used to extend the functionality of a class/protocol, even if it is a built-in one. </br>
Extension for built-in class ```Int```, return absolute value:
```swift
extension Int {
    var abs: Int {
        get {
            if self >= 0 {
                return self
            } else {
                return -self
            }
        }
    }
}
print((-3).abs))
```
Extension for ```Array```, return in reverse order:
```swift
extension Array {
    func reverse() -> Array {
        var temp = Array()
        var index = self.count - 1
        while index >= 0 {
            temp.append(self[index])
            
            index -= 1
        }
        return temp
    }
}
```
Extension for ```Double```, switch to meters:
```swift
extension Double {
    var km: Double { return self * 1_000.0 }
    var m: Double { return self }
    var cm: Double { return self / 100.0 }
    var mm: Double { return self / 1_000.0 }
    var ft: Double { return self / 3.28084 }
}
let marathon = 42.km + 195.m    //marathon = 42195.0
```
We can also use extension to write default function for a protocol. So we don't need to define it again in every class.
```swift
extension Tax {
    mutating func changeStateTax (newTax: Double) {
        state = newTax
    }
}
```
</br>




